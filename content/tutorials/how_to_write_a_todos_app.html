<!-- HEADER -->
<div class="contentHeader">
    <a name="top"></a>

    <h1>How to write a ToDo App</h1>

    <div class="directoryPath">
        Creating a simple app to store your tasks, persistent.
	</div>

    <span class="navlink" onclick="scroll('overview')">Overview</span> &#183;
    <span class="navlink" onclick="scroll('screens')">Screenshots</span> &#183; 
    <span class="navlink" onclick="scroll('projectCreation')">1) Project initialization</span>
    <span class="navlink" onclick="scroll('createView')">2) The View part</span>
    <span class="navlink" onclick="scroll('createModel')">3) The Model part</span>
    <span class="navlink" onclick="scroll('createController')">4) The Controller Part</span>
</div>
<!-- END OF HEADER -->

<!-- BASICS-->
<div class="contentOverview">
    <a name="overview"><h2 class="line">Overview</h2></a>

    <p class="text">
        The ToDo App is a simple mobile web application to manage your daily tasks.
        It uses HTML5 LocalStorage to persist the task items.
        This guide is also a short little introduction for developers to build apps with The-M-Project.
    </p>
    <p>
        <a href="http://www.w3.org/html/logo/">
            <img src="http://www.w3.org/html/logo/badge/html5-badge-h-css3-graphics-storage.png" width="197" height="64" alt="HTML5 Powered with CSS3 / Styling, Graphics, 3D &amp; Effects, and Offline &amp; Storage" title="HTML5 Powered with CSS3 / Styling, Graphics, 3D &amp; Effects, and Offline &amp; Storage">
        </a>
    </p>

    <p class="text">
        You will learn the following:
        <ul class="text">
            <li>Generally, developing native-looking, feature-rich and offline-capable apps with The-M-Project</li>
            <li>Using Espresso - The-M-Project's little friend - to build, optimize and deploy your app</li>
            <li>The interaction of Models, Views and Controllers</li>
        </ul>
    </p>

    <p class="text">
        You will need the following:
        <ul class="text">
            <li>Knowledge of HTML, CSS and especially <span class="navlink" onclick="loadArticle('introduction/javascript');">JavaScript</span></li>
            <li>An IDE or at least a text editor for editing</li>
            <li>A ready to start-installation of Espresso</li>
            <li>An open terminal to execute the Espresso commands</li>
        </ul>
    </p>
    <span class="navlink" onclick="scroll('top')">&uarr; top</span>
</div>
<!-- END OF BASICS -->

<!-- BASICS-->
<div class="contentScreens">
    <a name="screens"><h2 class="line">Screenshots</h2></a>

    <p class="text">
        The ToDo App is a simple mobile web application to manage your daily tasks.
        It uses HTML5 LocalStorage to persist the task items.
        This guide is also a short little introduction for developers to build apps with The-M-Project.
    </p>

    <table>
        <tr>
            <td><img width="150px" src="images/tutorials/screen_todos_1.png" alt="Screen 1 - Adding an item" /></td>
            <td><img width="150px" src="images/tutorials/screen_todos_2.png" alt="Screen 2 - Adding an item" /></td>
            <td><img width="150px" src="images/tutorials/screen_todos_3.png" alt="Screen 3 - List of persisted items" /></td>
        </tr>
        <tr>
            <td class="text">Adding a new item is easy. Just enter text into the field.</td>
            <td class="text">You can add one item after the other without having to click the field again.</td>
            <td class="text">Items are shown in the list and persisted.</td>
        </tr>
        <tr>
            <td><img width="150px" src="images/tutorials/screen_todos_4.png" alt="Screen 4 - the edit mode" /></td>
            <td><img width="150px" src="images/tutorials/screen_todos_5.png" alt="Screen 5 - confirmation of delete operation" /></td>
            <td></td>
        </tr>
        <tr>
            <td class="text">By tapping the 'Edit' button on the upper right, <br /> you enter the 'Edit' mode, where you can delete <br /> items from the list.
    Look at the label at the top <br /> showing the number of items in the list: thanks to *data binding*, it is updated also!</td>
            <td class="text">Before definite deletion, you're asked to confirm the delete operation.</td>
            <td></td>
        </tr>
    </table>


    <span class="navlink" onclick="scroll('top')">&uarr; top</span>
</div>
<!-- END OF BASICS -->


<div class="contentCreateAProject">
    <a name="projectCreation"><h2 class="line">The coding part: 1) Project initialization</h2></a>

    <p class="text">
        Thanks to our little helper <span class="navlink" onclick="loadArticle('introduction/what_is_espresso');">Espresso </span> it's easy to create a new The-M-Project-App.
        We just have to use the command line tool <span class="code">espresso init</span> to initialize a new project. It has the following syntax:
    </p>
        <pre class="syntax shell">
espresso init [&lt;options&gt;]
</pre>

    <p class="text">
        It has the following options (that are displayed when you just enter <span class="code">espresso init</span>):
    </p>
        <table class="text">
            <tr>
                <td><span class="code">-p, --project==PROJECT</span></td>
                <td>Project name</td>
            </tr>
            <tr>
                <td><span class="code">-d, --directory==DIRECTORY</span></td>
                <td>Specify a custom projects directory, Default: $PWD</td>
            </tr>
            <tr>
                <td><span class="code">-e, --example</span></td>
                <td>Generate an example "Hello World" application, Default: $PWD</td>
            </tr>
            <tr>
                <td><span class="help">-h, --help</span></td>
                <td>Show this help for command init, Default: $PWD</td>
            </tr>
        </table>

    <p class="text">We want to have an empty project, not the samle project and we are in the right directory. So, we just enter the following command on the command line:</p>
        <pre class="syntax shell">
espresso init -p Todos
</pre>

    <p class="text">
        We're then receiving the messages that all needed files to start have been created. Also, a directory with our project name as name has been created. 
        Your Todos app directory should now look like the following:
    </p>
    <img src="images/tutorials/screen_directory_structure.png" alt="Todos App directory structure" />
    <p class="text">
        So we can just head into
        this directory:
    </p>
    <pre class="syntax shell">
cd Todos/
</pre>
</div>
<span class="navlink" onclick="scroll('top')">&uarr; top</span>






<div class="contentCreateTheView">
    <a name="createView"><h2 class="line">The coding part: 2) The View Part</h2></a>

    <p class="text">
        When we look at the screens, we can determine several view components that we need for this application:
    </p>

    <ul class="isFirstLine text">
        <li>a header bar</li>
        <li>a label showing the current number of items in the list</li>
        <li>a label completing the 'number of items' label with a sentence (here: item(s) left.)</li>
        <li>an input field to insert text for a todo item</li>
        <li>a list showing all todo items</li>
        <li>an edit button to delete items from the list, placed in the header bar</li>
    </ul>

    <img src="images/tutorials/screen_todos_views.png" alt="The view components of our app." />

    <p class="text">
        Optionally (and normally you would do this) there could be a button for adding the item to the list.
        In our case, we skipped this element, we add todo items by simply pressing the 'return' key on our (virtual) keyboard after inserting text.
        Remember this, 'cause we will come back to this behaviour when we show the event handling.
    </p>
    <p class="text">
        We only have one page. We can place all view elements on this page. But first, we have to create the view file. As with project initialization, Espresso helps here, a lot:
        Just type into your shell
    </p>
    <pre class="syntax shell">
espresso generate
</pre>
    <p class="text">and you will get all the options for it. We're now needing the <span class="code">-v</span> option to create a new page.</p>
    <pre class="syntax shell">
espresso generate -v TodosPage
</pre>
    <div class="note text">
	Please note, that you should be in the directory of your app to correctly execute the command.
	</div>
    <p class="text">
        On success, a message is shown in the command line, indicating the successful generation of your file. We will look into the file later. We first should "register" the page
        to have it accessible under a unique name throughout the app.
    </p>

    <h3>Registering a page</h3>
    <p class="text">To register our recently created page, we just have to assign it in the <span class="code">main.js</span> file in <span class="code">app/main.js</span>. This file
    also assigns our app's namespace. This is what it looks like:</p>
    <pre class="syntax javascript">
var Todos  = Todos || {};

Todos.app = M.Application.design({

    /* Define the entry/start page of your app. This property must be provided! */
    entryPage : 'page1',

    page1: M.PageView.design({

        //Add your code here!

    })

});</pre>

    <p class="text">
        The interesting part begins with the <span class="code">entryPage</span> property. With it, we define the entry page of our app, that means, the page that is shown first.
        Right now, the code declares <span class="code">page1</span> as the entry page. But it's an empty page. We want our recently created <span class="code">TodosPage</span> to be
        registered here. So we delete the inline definition of the page (the part beginning with <span class="code">M.PageView.design({...</span>) and just replace it with the correct and complete
        object path instead: <span class="code">Todos.TodosPage</span>. We also rename the property name from <span class="code">page1</span> to <span class="code">todos</span> (it can
        have every name as long as the name complies with the rules for variable naming in JavaScript). But we also have to change the value of the <span class="code">entryPage</span> now.
        In total, it should look like this then:
    </p>
    <pre class="syntax javascript">
var Todos  = Todos || {};

Todos.app = M.Application.design({

    /* Define the entry/start page of your app. This property must be provided! */
    entryPage : 'todos',

    todos: Todos.TodosPage

});</pre>

    <div class="note text">
        Note: The name that we're giving the property is also the name we're passing as first parameter to the <span class="code">getView</span> call of the
        <span class="navlink" onclick="loadArticle('components/m_viewmanager');">M.ViewManager </span> object.
    </div>


   <h3>The page in detail</h3>
   <p class="text">
       We already exposed the view components that shall be part of our page to let users create and manage their todos.
       We need to define these components in our recently created
       <span class="code">TodosPage</span>. Let's have a look into its content. Besides the comment on top, it includes the following code:
   </p>

<pre class="syntax javascript">
    Todos.TodosPage = M.PageView.design({

        /* Use the 'events' property to bind events like 'pageshow' */
        events: {
            pageshow: {
                target: Todos.MyController,
                action: 'init'
            }
        },

        childViews: 'header content footer',

        header: M.ToolbarView.design({
            value: 'HEADER',
            anchorLocation: M.TOP
        }),

        content: M.ScrollView.design({
            childViews: 'label',
            label: M.LabelView.design({
                value: 'Todos2Page'
            })
        }),

        footer: M.ToolbarView.design({
            value: 'FOOTER',
            anchorLocation: M.BOTTOM
        })
});</pre>

        <p class="text">
            The page consists of three parts:
        </p>
            <table class="reference" cellpadding="0" cellspacing="0">
                <tr style="height:50px;">
                    <td>
                        <span class="code">header</span>
                    </td>
                    <td>
                        <p class="text">The toolbar on top. It's possible to put child views into it, like a button on the right side. At default, it already
                        includes a child view: a label having the value "HEADER". The above shown definition format is the short form of manually adding
                        a LabelView to it.</p>
                    </td>
                </tr>
                <tr style="height:50px;">
                    <td>
                        <span class="code">content</span>
                    </td>
                    <td>
                        <p class="text">The typical content area below the header toolbar. Includes all views components that are not part of the header or footer.
                            If no child views are added here, nothing is shown.
                        </p>
                    </td>
                </tr>
                <tr style="height:50px;">
                    <td>
                        <span class="code">footer</span>
                    </td>
                    <td>
                        <p class="text">
                            The toolbar at the bottom. The same definition as the header bar, but it is positioned on the bottom of each page. If
                            <span class="code">isFixed: YES</span> is provided, it always fades out when content is scrolled and fades in when the scrolling stopped.
                            If <span class="code">isFixed: NO</span> is passed it is positioned on the "real" bottom of the view. That means if the content's height is double
                            the screen size, the toolbar is not shown when the screen is scrolled to top.
                        </p>
                    </td>
                </tr>
            </table>
            <div class="note text">
            Note: The names of the three components are exchangeable of course. You can name them as you like, your only limitation is the variable name format definition of JavaScript.
                You can also add more components as those three shown in the code above. You just have to name them in the <span class="code">childViews</span> property of the page.
            </div>

    <p class="text">
        We will not use the footer in this app. You can delete it from this page definition.
    </p>
    <span class="navlink" onclick="scroll('top')">&uarr; top</span>






    <h3>The header</h3>
    <p class="text">As we see from the screenshots above, our header will contain a label (the app title) and a button that activates the edit mode on our tasks. We also need a button to end the
    edit mode. That makes two buttons. We want to place them on the same position and use a ToggleView to toggle between both buttons.</p>
    <p class="text">
        This is how we replace our header definition:
    </p>

<pre class="syntax javascript">
header: M.ToolbarView.design({
  anchorLocation: M.TOP
  childViews: 'centerLabel toggleView',

  toggleView: M.ToggleView.design({
    childViews: 'button1 button2',

    anchorLocation: M.RIGHT,

    toggleOnClick: YES,

    button1: M.ButtonView.design({
      value: 'Edit',
      icon: 'gear'
      events: {
        tap: {
          target: Todos.TodosController,
          action: 'edit'
        }
    }),

    button2: M.ButtonView.design({
      value: 'Save',
      icon: 'check',
      events: {
        tap: {
          target: Todos.TodosController,
          action: 'edit'
        }
      }
    })
  }),

  centerLabel: M.LabelView.design({
    value: 'Todos',
    anchorLocation: M.CENTER
  })
})
</pre>
    <p class="text">Now in detail: </p>
    <p class="text">The header is a <span class="navlink" onclick="loadArticle('views/m_toolbarview');">ToolbarView</span>. Its property <span class="code">anchorLocation</span> defines the position of the Toolbar. There are two possibilities:</p>
    <ul class="text">
        <li><span class="code">M.TOP</span>: Toolbar at the top of the page.</li>
        <li><span class="code">M.BOTTOM</span>: Toolbar at the bottom of the page.</li>
    </ul>
    <p class="text">A ToolbarView is also a container for other views. In our case, it contains a label and a toggle, which itself again contains two buttons.
    To have the nested views rendered, they need to be included in the <span class="code">childViews</span> string. Therefor we simply append the property name
    to the string, here "toggleView" and "centerLabel".
    </p>

    <div class="note text">
    Note: It's not the definition order in the object literal that defines the rendering order of the views. It's the order they are named in the <span class="code">childViews</span> string.
    </div>


    <p class="text">
        Next, we define the <span class="navlink" onclick="loadArticle('views/m_toggleview');">ToggleView</span>. When defined in a ToolbarView, it must have the <span class="code">anchorLocation</span>
        property set. We want to have the buttons on the right side of the toolbar, that's why we set it to <span class="code">M.RIGHT</span>. The ToggleView takes two child views, one for each
        state it is in. In our app, we have two buttons that we're defining here as <span class="navlink" onclick="loadArticle('views/m_buttonview');">M.ButtonView</span>.
    </p>

    <p class="text">
        The last thing we're defining in the header is the label. It shows a static text, 'Todos' and is placed in the center (see the <span class="code">anchorLocation</span> property).
        That's it for the header. Next: the content area.
    </p>



    <h3>The content area</h3>
    <p class="text">
        As a convention, the standard container element for the content area is a M.ScrollView. The following snippet is the replacement for the generated content object in our page.
    </p>

<pre class="syntax javascript">
    content: M.ScrollView.design({

      /* order in childViews string defines render order*/
      childViews: 'counter text inputField todoList',

      counter: M.LabelView.design({
        value: '0',
        contentBinding: {
            target: Todos.TodoController,
            property: 'counter'
        }
        isInline: YES
      }),

      text: M.LabelView.design({
        value: ' item(s) left.',
        isInline: YES
      }),

      inputField: M.TextFieldView.design({
        initialText: 'Enter ToDo Item...',

        events: {
            enter: {
                target: Todos.TodoController,
                action: 'addTodo'
            }
        }
      }),

      todoList: M.ListView.design({
        listItemTemplateView: Todos.TodoItemView
        contentBinding: {
            target: Todos.TodoController,
            property: 'todos'
        }
      })
    })
</pre>

<p class="text">
    As the first child, we have a label (counter) showing the current number of todo items in the list.
</p>

<pre class="syntax javascript">
counter: M.LabelView.design({
    value: 0,
    contentBinding: {
        target: Todos.TodoController,
        property: 'counter'
    }
    isInline: YES
  }),
</pre>

<p class="text">
    Its initial value is 0, because at the very first application start, no item is in the list. For the current number state of the list,
    we define a content binding on the controller value, that represents the number of items.
    When this value changes, the label view is notified and renders the update (see <span class="navlink" onclick="loadArticle('core_concepts/content_binding');">content Binding</span>).
</p>
<p class="text">
    Because we want to have a text placed next to the counter label, we set its isInline property to YES.
</p>

<div class="note text">
    Note: <span class="code">YES</span> is an alias for <span class="code">true</span> and vice versa, <span class="code">NO</span> is an alias for <span class="code">false</span>.
</div>
<p class="text">
    The text next to the counter is represented by a label:
</p>

<pre class="syntax javascript">
text: M.LabelView.design({
    value: ' item(s) left.',
    isInline: YES
  }
</pre>

<p class="text">
    It has no content binding, its content/value is somehow static, though its content could be changed in code. <br />
</p>

<span style="font-weight:bold;">An alternative label solution with dynamic value computing</span>
<p class="text">
    To be honest, the above shown solution with two labels is not the sexiest way to fulfill this task. First, we have to design two labels and second, showing
    "item(s)" is not the coolest way to set the plural form of the word "item". Why did I do it like this, then? I just wanted to show you a reasonable way of
    handling this task and I wanted to show you the <span class="code">isInline</span> property. But here's an alternative with just one label defined.
</p>

<pre class="syntax javascript">
counter: M.LabelView.design({
    computedValue: {
        contentBinding: {
            target: Todos.TodoController,
            property: 'counter'
        },
        value: 0,
        operation: function(v) {
            if(v > 1) {
                return v + ' items left.';
            } else {
                return v + ' item left.';
            }
        }
    }
  })
</pre>
<p class="text">
    We also have a content binding on the counter property. But we define it in an object named <span class="code">computedValue</span>. With that object we're using
    <span class="navlink" onclick="loadArticle('core_concepts/dynamic_value_computing')">Dynamic Value Computing</span> and need to define a function named <span class="code">
    operation</span> in it. It is called on rendering and on update rendering. The actual value is passed to it. We distinguish the value and return either the singular form or
    the plural form of "item(s)". It's cooler than the solution before, isn't it?
</p>

<p class="text">
    Ok, let's get back to business... Our next view element is a text field where the user can enter new todo tasks.
</p>    
    
<pre class="syntax javascript">
inputField: M.TextFieldView.design({
    initialText: 'Enter ToDo Item...',

    events: {
        enter: {
            target: Todos.TodoController,
            action: 'addTodo'
        }
    }
}),
</pre>

<p class="text">
    The <span class="code">initialText</span> property defines a text that is shown inside the text field while not having the focus.
    The next property is the event object. Here we're defining all event bindings for this input field. You can read about the recommended events in the
    <span class="navlink" onclick="loadArticle('views/m_textfieldview');"> TextFieldView doc</span>. In this case, we will just create a binding for the
    "enter" event, which is a custom created event being triggered when the user presses the "enter" or "return" key. The object defines two properties:
</p>
    <ul class="text">
        <li>
            <span class="code">target: </span>
            Defines the scope for the action defined below. If the name of a controller method is passed to <span class="code">action</span> the controller
            is set here (as seen in this snippet).
        </li>
        <li>
            <span class="code">action: </span>
            Here, we name <span class="code">addTodo</span> of the <span class="code">TodoController</span> as the action to be executed when "enter" is pressed.
            We could also define an anonymous function here that is executed, once the event is triggered.
        </li>
    </ul>

<p class="text">
    Our last element on the page is the list. Because a <span class="navlink" onclick="loadArticle('views/m_listview');">ListView</span> is slighty more complex than for example
    a ButtonView, we spend it an own section.
</p>

<h3>The list</h3>
<p class="text">
    Defining a list is not that complex. The ListView itself only has two important properties to be set: its content binding and the template view defining the structure of each list item:
</p>

<pre class="syntax javascript">
todoList: M.ListView.design({
    listItemTemplateView: Todos.TodoItemView
    contentBinding: {
        target: Todos.TodoController,
        property: 'todos'
    }
  })
</pre>

<p class="text">
    We bind the list to an array of todo items in the controller, named <span class="code">todos</span>. The property <span class="code">listItemTemplateView</span>
    references the template view object. Template views extend <span class="navlink" onclick="loadArticle('views/m_listitemview')">M.ListItemView</span>,
    are located in the applications "view/" directory and are defined by the developer.
</p>
    
<p class="text">
    Here's our template:
</p>

<pre class="syntax javascript">
Todos.TodoItemView = M.ListItemView.design({
  childViews: 'label1',

  label1 : M.LabelView.design({
    valuePattern: '<%= text %>'
  })
});
</pre>
    
<p class="text">
    The childViews string indicates that a ListItemView is a container for any number of other elements.
    We want the text of a todo item be shown. Therefor we define one LabelView:
</p>

<pre class="syntax javascript">
label1 : M.LabelView.design({
  valuePattern: '<%= text %>'
})
</pre>
    
<p class="text">
    The label's value property looks somehow strange to us until now. What do these angle brackets, the procent symbols and the equal sign mean? This is a special syntax that tells the framework to use a property named text of the binded object as the label's value. As mentioned above, we bind the list to an array of todo items in the controller. As we will see when discussing the model part of the app, each items has a text property and this kind of expression tells the list item to use it as its content. Because we defined the content binding in the ListView we are not binding anything here. In conclusion:
    the list is binded to an array of todo tasks.
    For each todo tasks a new list item is created with the text property of the particular todo task used as its value.
</p>
    
<p class="text">
    That's it for the view. All necessary view elements are set up and configured. What we need to know next, is the model.
</p>

<div class="note text">
    Note: Some parts of the view definition, e. g. the content binding properties, might be defined not until the controller is set up. But to have all parts of the view explained in one place, we already defined them.
    Note: Some parts of the view definition, e. g. the content binding properties, might be defined not until the controller is set up. But to have all parts of the view explained in one place, we already defined them.
    In practice this might be a more iterative process between view definition and controller set up.
</div>

<h2>What we've learned so far</h2>

<ul class="text">
    <li>A page represents one screen and contains different views that define the look of the screen.</li>
    <li>Pages often contain a header and/or footer and a content area.</li>
    <li>Dynamic values are done with the concept of <span class="navlink" onclick="loadArticle('core_concepts/dynamic_value_computing')">Dynamic Value Computing</span>.</li>
    <li>With <span class="navlink" onclick="loadArticle('core_concepts/content_binding')">content binding</span>, view elements can be bind to controller properties. Value changes are then automatically applied on the view.</li>
    <li>Some views are containers for other views. For example, a ToolbarView can take a button and a label as child views.</li>
    <li>The names of the child views have to be added to the <span class="code">childViews</span> property.</li>
    <li>The look of a list is defined by its template view: an object that extends <span class="navlink" onclick="loadArticle('views/m_listitemview')">M.ListItemView</span></li>
</ul>

</div>


<div class="contentCreateTheModel">
    <a name="createModel"><h2 class="line">The coding part: 3) The Model Part</h2></a>

    <p class="text">
        The best way to define and work with business data is to use the Model component of The-M-Project.
        In MVC Models represent entities of the application's domain for example: Person, Invoice, Order, Task, etc.
        In doing so, they represent also the application's data. They encapsulate the business logic and they know how to validate themselves.
        Usually models are persisted in a storage system like a database.
        In our Todos application we only have one model: a task. A task represents one todo item that needs to be done.
    </p>

    <p class="text">
        The model Task must be created in the applications models/ directory. Espresso does this for you automatically if you're using
    </p>

    <pre class="syntax shell">
    espresso generate -m Task</pre>
    <p class="text">
        to generate it. Power lies in simplicity: the only attribute of a todo task in our app is its text.
        Ok, now we just have to define it in the model:
    </p>

    <pre class="syntax javascript">
        Todos.Task = M.Model.create({

            __name__: 'Task',

            text: M.Model.attr('String', {
              isRequired:YES
            }

        }, M.DataProviderLocalStorage);
    </pre>
    
    <p class="text">
        Here the circle completes: Do you remember the list item template?
        We set the value of the only label in it to the strange looking string '<%= text %>'.
        <span class="code">text</span> refers to this model property!
    </p>

    <p class="text">
        The <span class="code">__name__</span> property is a meta property of the model. It doesn't belong to the model's data properties.
        It is used by the framework to identify its heritage.
    </p>
    
    <p class="text">
        The text property is define by calling <span class="code">M.Model.attr</span> with a parameter object.
        Here the content of the parameter object is just a flag defining whether this property
        is required for persisting or not. If the <span class="code">isRequired</span> flag is set to <span class="code">YES</span>,
        a <span class="code">M.PresenceValidator</span> is automatically added to the property to ensure that
        this property has been set with a value before persisting the model record.
    </p>
    
    <p class="text">
        That's all for the model itself. We will look into persistence later. Now let's have a look at the controller.
    </p>

    <h2>What we've learned so far</h2>

    <ul class="text">
        <li>Models represent the business data/entities of an application.</li>
        <li>To create a model, <span class="code">create</span> of <span class="code">M.Model</span> is called.</li>
        <li>A model is a blueprint, of which (model) records can be created</li>
        <li>Records are saved to a storage via a data provider, e.g. <span class="code">M.DataProviderLocalStorage</span></li>
    </ul>

</div>

<div class="contentCreateTheController">
    <a name="createController"><h2 class="line">The coding part: 4) The Controller Part</h2></a>
    
    
    <p class="text">
        A controller acts as the middle part or connector between the views and the models.
        Events from the view are dispatched to controller methods.
        These methods might interact with models and after completion invoke a view to render the results of this process.
        In our todo app we have one controller that is simply named TodoController.
        <br />
        Here's the full code:
    </p>

    <pre class="syntax javascript">
        Todos.TodoController = M.Controller.extend({

          todos: null,

          counter: 0,

          init: function() {
            this.set('todos', Todos.Task.find(););
            this.calculateCounter();
          },

          addTodo: function() {
            var text = M.ViewManager.getView('todosPage', 'inputField').value;
            if(!text) {
              return;
            }

            Todos.Task.createRecord({
                text: text
            }).save();

            this.set('todos', Todos.Task.records());

            this.calculateCounter();

            M.ViewManager.getView('todosPage', 'inputField').setValue('');
          },

          removeTodo: function(domId, modelId) {
            var doDelete = confirm('Do you really want to delete this item?');
            if(doDelete) {
              var record = Todos.Task.recordManager.getRecordForId(modelId);
              record.del();
              this.set('todos', Todos.Task.records());
              this.calculateCounter();
            }
          },

          calculateCounter: function() {
            this.set('counter', this.todos.length);
          },

          edit: function() {
            M.ViewManager.getView('todosPage', 'todoList').toggleRemove({
              target: this,
              action: 'removeTodo'
            });
          }
        });
    </pre>
    
    <p class="text">
        Let's have a look at the propably most important method, <span class="code">addTodo</span>:
    </p>

    <pre class="syntax javascript">
    addTodo: function() {
        var text = M.ViewManager.getView('todosPage', 'inputField').value;
        if(!text) {
          return;
        }

        Todos.Task.createRecord({
            text: text
        }).save();

        this.set('todos', Todos.Task.records());

        this.calculateCounter();

        M.ViewManager.getView('todosPage', 'inputField').setValue('');
    }
    </pre>
    
    <p class="text">
        As the name indicates, we use this method to add a new todo task.
        At first we have to get the user's input from the text field.
        The application global object <span class="navlink" onclick="loadArticle('components/m_viewmanager')">M.ViewManager</span> is the perfect one to ask for the
        <span class="code">ìnputField</span> object and its value.
        If no text was entered before pressing the return key we do nothing and return.
        We don't want empty tasks in our list. If a text has been entered we create a new Task with it and save it:
    </p>

    <pre class="syntax javascript">
        Todos.Task.createRecord({
            text: text
        }).save();
    </pre>
    
    <p class="text">
        We create a new model blueprint with create (see above in the model definition).
        But when creating new objects of this blueprint (we call them records) ,
        we use <span class="code">createRecord</span> and pass it all property values it needs.
        By using this method, we ensure that all properties passed as parameters are put at the
        correct place inside the model object where they are taken for persistence.
        If we would use <span class="code">create</span> here, we would not have this behaviour.
        Here, we simply pass the text that we've received from the text field before. Now that we've created a new task. To persist it, we call
        <span class="code">save</span> on the model object.
    </p>
    
    <p class="text">
        Now that the model was added and saved to storage we set the <span class="code">todos</span> property and re-calculate the counter.
    </p>

    <pre class="syntax javascript">
        calculateCounter: function() {
            this.set('counter', this.todos.length);
        }
    </pre>

    <p class="text">
        This invokes two updates in the view: one for the label showing the number of items and the other one in the list with a new item.
    </p>

    <p class="text">
        As a last step, we empty the text field to let the user easily add one todo task after the other.
        <br />
        Now let's have a look at <span class="code">removeTodo</span>:
    </p>

    <pre class="syntax javascript">
        removeTodo: function(viewId, recordId) {
            var doDelete = confirm('Do you really want to delete this item?');
            if(doDelete) {
              var record = Todos.Task.recordManager.getRecordForId(recordId);
              record.del();
              this.set('todos', Todos.Task.records());
              this.calculateCounter();
            }
        }
    </pre>

    <p class="text">
        The <span class="code">viewId</span> parameter (meaning the value of the tag's ID attribute) is passed to every method that's being invoked by a view
    through an event. For 'tap' events also the recordId is passed, if available.
    We need it here. But before removing anything, we want the user to be able to cancel the operation.
    Therefor we first popup a confirm box by using javascript's <span class="code">confirm</span> method.
    Only if the user confirmed to the question by pressing OK in the box, the operation is taking place.
    </p>
    
    <p class="text">
        First we get the model from the models <span class="code">M.RecordManager</span> with <span class="code">getRecordForId</span>.
        Every model has a record manager. We used it before with the <span class="code">records method</span>,
        which simply delegates a call to the model's record manager to simply return all
        currently saved models in memory. Next, we delete it. It is automatically deleted
        from the record manager's record list also. Then we set our controller property
        <span class="code">todos</span> with the now updated record manager record list by calling
        <span class="code">Todos.Task.records()</span>. As a last step we re-calculate the counter. That's all.
    </p>
    
    <p class="text">
        But how can we remove the todo items? This is a really good question. If we look at the list we can nowhere find a delete button or something similar.
        But we remember having added a <span class="code">ToggleView</span>.
        The buttons inside this view are bind on click to our <span class="code">TodoController</span>
        as target and <span class="text">edit</span> as action. Here is the latter:
    </p>

    <pre class="syntax javascript">
        edit: function() {
            M.ViewManager.getView('todosPage', 'todoList').toggleRemove({
              target: this,
              action: 'removeTodo'
            });
        }
    </pre>
    
    <p class="text">
        It simply makes one call to the toggleRemove method of the <span class="navlink" onclick="loadArticle('views/m_listview')">ListView</span>.
        We pass it two properties: a <span class="code">target</span> and an <span class="code">action</span> inside the target.
        <span class="code">toggleRemove</span> activates the edit mode of a list and forces it to re-render
        itself and to display a remove button for every list view item. Every
        remove button receives the previously passed <span class="code">target</span> and <span class="code">action</span> property.
        In our case, every tap event will trigger <span class="code">removeTodo</span>
        of the <span class="code">TodoController</span> for the item where the button was tap.
        When the <span class="code">ToggleView</span> is clicked again, the edit mode ends.
    </p>
    
    <h3>Loading all todos on application startup</h3>

    <p class="text">
        Up to now, no tasks are shown on application startup. In the controller code above, you're seeing a snippet we haven't discussed yet:
    </p>

    <pre class="syntax javascript">
        init: function(isFirstLoad) {
            this.set('todos', Todos.Task.find(););
            this.calculateCounter();
          }
    </pre>

    <p class="text">
        The code is straightforward. First, we set the controller property <span class="code">todos</span>
    with the result of the <span class="code">find</span> call on Task. With LocalStorage, find immediately returns the result
    of the call as an array of matching model records. Because we didn't specify anything, a "find all" is executed.
    </p>

    <div class="note text">
        Info: <span class="code">Todos.Task.find()</span> corresponds to <span class="code">SELECT * FROM Task</span> in SQL.
    </div>
    
    <p class="text">
        Second, we calculate the counter to have the correct number of Tasks displayed.<br />

        Ok, but when is it called? We never call <span class="code">init</span> in our controller code. It has to happen automatically
        on application startup. We accomplish this by binding to an event that occurs before the page is shown.
        A <span class="navlink" onclick="loadArticle('views/m_pageview')">PageView</span> has several events we can bind to. We'll use
        <span class="code">pagebeforeshow</span>. We define it inside the page:
    </p>

    <pre class="syntax javascript">
    Todos.TodosPage = M.PageView.design({

        events: {
            pageshow: {
                target: Todos.TodosController,
                action: 'init'
            }
        },
    </pre>
    
    <p class="text">
        Now <span class="code">init</span> is called, before the page is shown. The parameter that is passed to the binded method is a Boolean value
        defining whether the page is loaded for the first time (in this app lifecycle) or not.
    </p>

    <h2>What we've learned on controllers</h2>

        <ul class="text">
            <li>Controller contain the application logic and act as an interface between models and views.</li>
            <li>
                Each app normally has multiple controllers, for different logical parts in an app, e.g. a <span class="code">UserController</span>,
                a <span class="code">LoginController</span>, a <span class="code">RequestController</span>, etc.
            </li>
            <li>Controller are usually the targets of events triggered in the view.</li>
            <li>With the controller method <span class="code">set</span>, executed on a controller property, content binding is triggered. Just assigning
            a value to a controller property doesn't trigger it.</li>
        </ul>

</div>

<p class="text">
    <strong>That's it. We just completed our Todos app. It's not rich in functionality but it covers many parts a more
        complex app also targets.</strong>
</p>


